import numpy as np
from sklearn.model_selection import KFold
from sklearn.linear_model import Ridge
from imageio.v2 import imread
import matplotlib.pyplot as plt
from sklearn.metrics import mean_squared_error



def create_X(x, y, n ):
	if len(x.shape) > 1:
		x = np.ravel(x)
		y = np.ravel(y)

	N = len(x)
	l = int((n+1)*(n+2)/2)		# Number of elements in beta
	X = np.ones((N,l))

	for i in range(1,n+1):
		q = int((i)*(i+1)/2)
		for k in range(i+1):
			X[:,q+k] = (x**(i-k))*(y**k)

	return X

# Cross-validation
from sklearn.model_selection import cross_val_score

file_path = 'C:/Users/krist/Downloads/sognsvann.tif'
terrain = imread(file_path)

N = 1000
m = 10  # Polynomial order
terrain = terrain[:N, :N]

x = np.linspace(0, 1, np.shape(terrain)[0])
y = np.linspace(0, 1, np.shape(terrain)[1])
x_mesh, y_mesh = np.meshgrid(x, y)

z = terrain.flatten()
X = create_X(x_mesh, y_mesh, m)

polynomial = 10
k = 5
kfold = KFold(n_splits=k)

# Perform ridge regression and cross-validation
lamda = 0.000001
error = np.zeros(polynomial)
bias = np.zeros(polynomial)
variance = np.zeros(polynomial)
polydegree = np.zeros(polynomial)

for p in range(1, polynomial + 1):
    j = 0
    y_pred = np.empty((int(len(x) / k), k))

    for train_inds, test_inds in kfold.split(x):
        xtrain = x[train_inds]
        ytrain = y[train_inds]

        # Create design matrix for Ridge regression
        X_train = create_X(xtrain, ytrain, p)
        ztrain = z[train_inds]

        # Initialize and fit Ridge regression
        ridge_reg = Ridge(alpha=lamda)  # Set alpha to the regularization strength
        ridge_reg.fit(X_train, ztrain)

        xtest = x[test_inds]
        ytest = y[test_inds]

        # Create test design matrix for Ridge regression
        X_test = create_X(xtest, ytest, p)
        ztest = z[test_inds]

        # Make predictions using Ridge regression
        z_pred = ridge_reg.predict(X_test)

        y_pred[:, j] = z_pred
        j += 1

    mse = np.zeros(k)
    for i in range(k):
        mse[i] = mean_squared_error(ztest, y_pred[:, i])

    error[p - 1] = np.mean(mse)
    bias[p - 1] = np.mean((ztest - np.mean(y_pred, axis=1, keepdims=True)) ** 2)
    variance[p - 1] = np.mean(np.var(y_pred, axis=1, keepdims=True))
    polydegree[p - 1] = p

# Calculate MSE for Ridge regression
mse_ridge = mean_squared_error(z, ridge_reg.predict(X))
print(f"Mean Squared Error (MSE) for Ridge: {mse_ridge:.4f}")

# Calculate R-squared (R2) for Ridge regression
r2_ridge = ridge_reg.score(X, z)
print(f"R-squared (R2) for Ridge: {r2_ridge:.4f}")

# Create the design matrix for the entire dataset
X_ridge = create_X(x_mesh, y_mesh, polynomial)

# Fit Ridge regression to the entire dataset
ridge_reg.fit(X_ridge, z)

# Predict the elevation values for the entire dataset using Ridge regression
z_ridge = ridge_reg.predict(X_ridge)

# New 2D plot of the terrain after Ridge regression and cross-validation
plt.figure(figsize=(8, 6))
plt.imshow(z_ridge.reshape(N, N), cmap='viridis', extent=(0, 1, 0, 1))
plt.title("Terrain 2D Plot (Ridge Regression and Cross-Validation Result)")
plt.xlabel('East')
plt.ylabel('North')
plt.colorbar()
plt.show()

# New 3D plot of the terrain after Ridge regression and cross-validation
fig = plt.figure(figsize=(10, 7))
ax = fig.add_subplot(111, projection='3d')
Xgrid, Ygrid = np.meshgrid(x, y)
ZGrid = z_ridge.reshape(N, N)

surf = ax.plot_surface(Xgrid, Ygrid, ZGrid, cmap=plt.cm.coolwarm, linewidth=0, antialiased=False)
ax.set_xlabel ('East')
ax.set_ylabel('North')
ax.set_zlabel('Elevation')
ax.set_title("Terrain 3D Plot (Ridge Regression and Cross-Validation Result)")
plt.colorbar(surf, ax=ax, shrink=0.5, aspect=9)
plt.show()